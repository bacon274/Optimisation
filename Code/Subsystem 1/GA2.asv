%Genetic Algorithm Implementation for Subsystem 1

%Genetic Algorithm Implementation for Subsystem 1

%% Global Fixed Parameters 
global a1 a2 a3 a4 a5 i1 i2 i3 i4 i5 Results_Array_Energy Results_Array_Years Results_Array_Hrs_light Results_Array_Cost
% Area of Windows (m^2)
a1= 1.44; 
a2= 1.44; 
a3= 0.5; 
a4= 0.5; 
a5= 1.8;
% Yearly Light Irridance on Windows (kWh/m^2)
i1=1061.16;  
i2=1061.16;
i3=744.54;
i4=744.54;
i5=744.54;

% Results Arrays for plotting outcomes of GA
Results_Array_Energy = [];
Results_Array_Years = [];
Results_Array_Hrs_light = [];
Results_Array_Cost = [];


% Panel Information PS-M-NX
P1_area = 1.4;
P1_power_ub = 0.104; % note this is power /m^2 under test conditions
P1_power_lb = 0;
P1_to_g_poly_coef = [0, 38.395,   -13.6,    1.0007]; % this is the list of polynomial coefficients that map Power onto transparency

P1_cost = 400; % cost per panel

P1 = [P1_area,P1_power_ub,P1_power_lb,P1_to_g_poly_coef,P1_cost];

% Panel Information PS-CT
P2_area = 0.72;
P2_power_ub = 0.072; % note this is power /m^2 under test conditions
P2_power_lb = 0;
P2_to_g_poly_coef = [0,  0,  -12.5, 1.0000]; % this is the list of polynomial coefficients that map Power onto CHANGE THIS FOR % TRANSPARENCY
P2_cost = 400; % cost per panel

P2 = [P2_area,P2_power_ub,P2_power_lb,P2_to_g_poly_coef,P2_cost];

%% Functions

% add linear inequality constraints

% we know from polyfit g =  -4.4103e-07*p^3 + 9.4322e-05*p^2 -0.0072*p^3 + 0.5518
% however this might need to be linear in which case g =  -0.0031*p +  0.5755

%run_ga(P1)
%run_fmincon(P1)

figure()
scatter3(Results_Array_Energy,Results_Array_Hrs_light,Results_Array_Cost)
% Algorithm Functions
function run_fmincon(P)
    P_area = P(1);
    P_power_ub = [P(2);P(2);P(2);P(2);P(2);];
    P_power_lb = [0;0;0;0;0;];
    P_to_t_coef = P(4:7);
    P_cost = P(8);
    
    %Objective Function
    f = @(x) objective(x,P_area,P_cost);
    %Constraint Fucntion
    cf = @(x) confuneq(x,P_to_t_coef,P_area,P_cost);
    x0 = [0 0 0 0 0];
    [x,fval,exitflag,output] = fmincon(f,x0,[],[],[],[],P_power_lb,P_power_ub,cf)
    Test(x,P_to_t_coef,P_area,P_cost)
end
function run_ga(P)
    % Load Panel Properties
    P_area = P(1);
    P_power_ub = [P(2);P(2);P(2);P(2);P(2);];
    P_power_lb = [0;0;0;0;0;];
    P_to_g_coef = P(4:7);
    P_cost = P(8);
    
    %Objective Function
    f = @(x) objective(x,P_area,P_cost);
    %Constraint Fucntion
    cf = @(x) confuneq(x,P_to_g_coef,P_area,P_cost);
    
    Number_variables = 5;
    X0 = [0 0 0 0 0]; % start point
    options.InitialPopulationMatrix = X0; 
    
    [x,fval,exitflag,output] = ga(f, Number_variables,[],[],[],[],P_power_lb,P_power_ub,cf,options)
    if exitflag == -2
        run_ga(P)
    else
        Test(x,P_to_g_coef,P_area,P_cost)
    end
    
    
end
%Objective and Constrain
function [c,ceq] = confuneq(x,P_to_t_coef,P_area,P_cost)
    global Results_Array_Energy Results_Array_Hrs_light Results_Array_Cost
    % non-linear inequality constraint 
    %Light Hours of the day that qualify
    Hrs_qualify = Light(x,P_to_t_coef);
    %Energy generated by Array
    Energy_generated = Array_energy(x);
    %Array cost
    Cost = Array_cost(x,P_area,P_cost);
   
    c1 = 6 - Hrs_qualify;    % 5 hours of good natural light per day 
    c2 = 100 - Energy_generated ;  % Energy generated minimum 
    c3 = Cost-3000; % cost belw £5000
    
    c = [c1;
         c2
         c3];
    ceq = [];
    
    %Add resuls to Results Array 
    Results_Array_Energy = [Results_Array_Energy, Energy_generated];
    Results_Array_Hrs_light = [Results_Array_Hrs_light, Hrs_qualify];
    Results_Array_Cost = [Results_Array_Cost, Cost];
end
function z = objective(x,P_area,P_cost) % x1-5 = power rating  % need to add in panel information and hence work out how many panels per window
    global Results_Array_Years 
    % assign costs for windows
    Cost = Array_cost(x,P_area,P_cost);
    Energy_generated = Array_energy(x);
    Annual_payback = FIT_payback(Energy_generated);
    Years_to_payback = Years(Cost,Annual_payback);
    z = Years_to_payback;
    Results_Array_Years = [Results_Array_Years,Years_to_payback];
end
% Calculation Functions:
function e = Array_energy(x)
    global a1 a2 a3 a4 a5 i1 i2 i3 i4 i5
    e = ((x(1)*i1*a1)+(x(2)*i2*a2)+(x(3)*i3*a3)+(x(4)*i4*a4)+(x(5)*i5*a5));
end
function f = FIT_payback(e)
    f = e*0.386;
end
function y = Years(c,f)
    y = c/f;
end
function c = Array_cost(x,P_area,P_cost)
    global a1 a2 a3 a4 a5
    if x(1) == 0 
        c1 = 0;
    else
        panels = ceil(a1/P_area);
        c1 = P_cost*panels + 500;
    end
    
    if x(2) == 0
        c2 = 0;
    else
        panels = ceil(a2/P_area);
        c2 = P_cost*panels + 500;
    end
  
    if x(3) == 0
        c3 = 0;
    else
        panels = ceil(a3/P_area);
        c3 = P_cost*panels + 500;
    end
    
    if x(4) == 0
        c4 = 0;
    else
        panels = ceil(a4/P_area);
        c4 = P_cost*panels + 500;
    end
    
    if x(5) == 0
        c5 = 0;
    else
        panels = ceil(a5/P_area);
        c5 = P_cost*panels + 500;
    end
    c = c1+c2+c3+c4+c5;
end 
function hrs = Light(x,P_to_t_coef)
    global a1 a2 a3 a4 a5 
    % Initialise values
    Hrs_qualify = 0; % the number of hours in the day that are above the threshold amount
    
    % Parameters
    a = [a1,a2,a3,a4,a5]; % Area values for each window 
    % Yearly Irridiance values per window should these go at beginning and
    % made global?
    d = [0.4,1.5,1.5,2,2]; % distances from each window to workspace 
    I_roof = [0,0,0,0,0,0,0,0,4,107,98,84,78,67,51,24,1,0,0,0,0,0,0,0]; % irridiance values for day in january 
    I_wall = [0,0,0,0,5,80,80,100,100,80,40,30,10,7,4,2,0,0,0,0,0,0,0,0]; % irridiance values for day in january 
    
    
    % Calculate Light Levels for each hour of the day, for each window.
    % Tolling up the number of hours that qualify
    for k = 1:24
        Lux_total = 0;
        for j = 1:5
            transparency = round(polyval(P_to_t_coef,x(j)),2); % working out the g value from linear regression value CHANGE
            if j == 1 || j ==2
                I = I_roof;
            else
                I = I_wall;
            end
            
            lm = I(k)*transparency*a(j)*683; % light in lumens for window 
            Lux = lm/(9*d(j)^2); % the lux values on the table should this take area into account?
            Lux_total = Lux_total + Lux;
            
        end
        if Lux_total > 30000
            Hrs_qualify = Hrs_qualify + 1;
        end 
    end
    hrs = Hrs_qualify;
end
%Test Output from solver
function t = Test(x,P_to_t_coef,P_area,P_cost)
    Cost_pounds = Array_cost(x,P_area,P_cost);
    Energy_generated_kWh = Array_energy(x);
    Annual_payback_pounds = FIT_payback(Energy_generated_kWh);
    Years_to_payback = Years(Cost_pounds,Annual_payback_pounds);
    Hrs_light_qualify = Light(x,P_to_t_coef);
    
    T = table(x(1),x(2),x(3),x(4),x(5),Years_to_payback,Cost_pounds,Energy_generated_kWh,Annual_payback_pounds,Hrs_light_qualify)
    
end
